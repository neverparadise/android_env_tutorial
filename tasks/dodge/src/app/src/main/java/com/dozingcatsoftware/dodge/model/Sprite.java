package com.dozingcatsoftware.dodge.model;

/**
 * Represents an object moving on a Field. A Sprite contains a current position, target position, speed,
 * and color. The default implementation moves in a straight line toward the target position.
 *
 * @author brian
 */
@SuppressWarnings("unused")
public class Sprite {

    Vec2 position;
    Vec2 targetPosition;
    double speed;
    private int[] color;

    /**
     * Returns the distance between the current position and target position.
     */
    private double distanceToTarget() {
        return position.distanceTo(targetPosition);
    }

    /**
     * Returns the squared distance between the current position and target position. This can be
     * used to avoid square root operations.
     */
    double squaredDistanceToTarget() {
        return position.squaredDistanceTo(targetPosition);
    }

    /**
     * Updates the position by moving closer to the target position.
     *
     * @param dt time interval since the last update
     */
    public void tick(double dt) {
        if (position == null || targetPosition == null) {
            return;
        }
        double dist = speed * dt;
        double distToTarget = this.distanceToTarget();
        if (dist >= distToTarget) {
            this.position = this.targetPosition;
        } else {
            // "correct" way treating position as immutable object
			/*
			Vec2 dir = this.targetPosition.subtract(this.position).normalize();
			this.position = this.position.add(dir.multiply(dist));
			*/
            // fast way updating position fields and not creating new objects
            double xNorm = (targetPosition.x - position.x) / distToTarget;
            double yNorm = (targetPosition.y - position.y) / distToTarget;
            position.x += dist * xNorm;
            position.y += dist * yNorm;
        }
    }

    /**
     * Clamps the x and y positions to minimum and maximum values. Subclasses that want to stay inside
     * specific ranges can call this method.
     */
    void enforceBounds(double xMin, double yMin, double xMax, double yMax) {
        if (position.x < xMin) {
            position.x = xMin;
        }
        if (position.x > xMax) {
            position.x = xMax;
        }
        if (position.y < yMin) {
            position.y = yMin;
        }
        if (position.y > yMax) {
            position.y = yMax;
        }
    }

    // autogenerated
    public Vec2 getPosition() {
        return position;
    }

    void setPosition(Vec2 position) {
        this.position = position;
    }

    public Vec2 getTargetPosition() {
        return targetPosition;
    }

    public void setTargetPosition(Vec2 targetPosition) {
        this.targetPosition = targetPosition;
    }

    public double getSpeed() {
        return speed;
    }

    void setSpeed(double speed) {
        this.speed = speed;
    }

    public int[] getColor() {
        return color;
    }

    void setColor(int[] color) {
        this.color = color;
    }
}
